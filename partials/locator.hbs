<div class="pb-2 mb-6 bg-orange-700 pt-8"></div>
<div class="full-width-locator">
  <div class="panel">
    <div class="header-section">
        <div class="lp-param lp-param-{$customizationInstanceID}-headline header">
            <h1> Local Locker locations near you</h1>
        </div>
      <div class="directions">
       
      </div>
      <div class="error-text"></div>
      <div class="search-bar">
        <input type="text" class="form-control lp-param-placeholderText" id="location-input" placeholder="E.g. Lower East Side" aria-label="E.g. New York">
        <input type="submit" value="Search" class="btn btn-primary bg-red-500  text-white border-red-500 focus:ring-2 focus:bg-red-900 border px-4 py-2 rounded transform hover:-translate-y-1 ease-in-out transition-all cursor-pointer hover:shadow-lg block text-center focus:outline-none" id="search-location-button">
        <div class="btn btn-link lp-param-requestLocationText ml-auto" onclick="getUsersLocation();" role="button">
            Use my location
        </div>
      
      </div>
      {{!-- <div class="search-center"></div> --}}
    </div>
    <div class="spinner" style="display: none;">
      <div class="sk-wave">
        <div class="sk-rect sk-rect1"></div>
        <div class="sk-rect sk-rect2"></div>
        <div class="sk-rect sk-rect3"></div>
        <div class="sk-rect sk-rect4"></div>
        <div class="sk-rect sk-rect5"></div>
      </div>
    </div>
    <div class="result-list">
      <div class="result-list-inner">
      </div>
    </div>
  </div>
  <div id="map"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/libphonenumber-js/1.7.22/libphonenumber-js.min.js"></script>
<script src="https://assets.sitescdn.net/rtf-converter/rtf-converter.min.js"></script>

<script>
  var limit = 5;
  var radius = 50;
  const defaultQuery = "Manhattan";
  var locationInput = document.getElementById("location-input");
  var searchButton = document.getElementById("search-location-button");
  var locationNoun = "Locations";
  var locationNounPlural = "Locations";

  // Live Api query variables.
  var liveAPIKey = 'c1be28fe46a4efb864aa9d8583108490';
  var savedFilterId = '551464658';
  var entityTypes = "location";
  var loadLocationsOnLoad = false;
  var enableAutocomplete = true;
  var base_url = "https://liveapi.yext.com/v2/accounts/me/";
  var useMiles = true;

  function getLocationOptions() {
    return {
      cardTitle: {
        value: "name",
        contentSource: "FIELD",
      },
      cardTitleLinkUrl: {
        value: "slug",
        contentSource: "FIELD",
      },
      hours: {
        value: "hours",
        contentSource: "FIELD",
      },
      address: {
        value: "address",
        contentSource: "FIELD",
      },
      availability: {
        value: "c_limitedAvailability",
        contentSource: "FIELD",
      },
      phoneNumber: {
        value: "mainPhone",
        contentSource: "FIELD",
      },
      getDirectionsLabel: {
        value: "Get Directions",
        contentSource: "text",
      },
      coordinates: {
        value: "geocodedCoordinate",
        contentSource: "FIELD",
      },
      viewDetailsLinkText: {
        value: "View Details",
        contentSource: "text",
      },
      viewDetailsLinkUrl: {
        value: "/",
        contentSource: "text",
      },
    };
  }

  function unescapeHtmlString(html) {
    const dom = new DOMParser().parseFromString(html, "text/html").documentElement
      .textContent;
    return dom.documentElement ? dom.documentElement.textContent : "";
  }

  // Make sure params are acceptable
  if (limit > 50) limit = 50;
  if (limit < 5) limit = 5;
  if (radius > 500) radius = 500;
  if (radius < 1) limit = 1;
  var selectedLocationIndex = -1;
  var currentLatitude = 0.0;
  var currentLongitude = 0.0;

  var isLoading = false;
  var locations = [];

  searchButton.addEventListener("click", function () {
    getNearestLocationsByString();
  });

  function startLoading() {
    isLoading = true;

    [].slice
      .call(document.querySelectorAll(".spinner") || [])
      .forEach(function (el) {
        el.style.visibility = "visible";
      });
    //[].slice
      //.call(document.querySelectorAll(".search-center") || [])
      //.forEach(function (el) {
      //  el.innerHTML = "";
     // });
    [].slice
      .call(document.querySelectorAll(".result-list") || [])
      .forEach(function (el) {
        el.style.visibility = "hidden";
      });
    locationInput.disabled = true;
    [].slice
      .call(document.querySelectorAll(".search") || [])
      .forEach(function (el) {
        el.classList.add("disabled");
      });
  }

  function stopLoading() {
    isLoading = false;

    [].slice
      .call(document.querySelectorAll(".spinner") || [])
      .forEach(function (el) {
        el.style.visibility = "hidden";
      });
    [].slice
      .call(document.querySelectorAll(".result-list") || [])
      .forEach(function (el) {
        el.style.visibility = "visible";
      });
    locationInput.disabled = false;
    [].slice
      .call(document.querySelectorAll(".search") || [])
      .forEach(function (el) {
        el.classList.remove("disabled");
      });
  }

  function formatPhone(phoneNumberString, countryCode) {
    if (!libphonenumber.isSupportedCountry(countryCode)) {
      return phoneNumberString;
    }
    const phoneNumber = libphonenumber.parsePhoneNumberFromString(
      phoneNumberString,
      countryCode
    );
    return phoneNumber.format("NATIONAL");
  }

  function formatNumber(numberString) {
    return numberString.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }

  function formatMiOrKm(miles, kilometers) {
    if (useMiles) {
      return miles.toFixed(0) + " mi.";
    } else {
      return kilometers.toFixed(0) + " km.";
    }
  }

  function timeStringToNumber(timeString) {
    const parts = timeString.split(":");
    const hours = parseInt(parts[0].replace(/\u200E/g, ""), 10);
    const minutes = parseInt(parts[1].replace(/\u200E/g, ""), 10);
    return hours + minutes / 60;
  }

  // Formats hours function
  // Open · Closes at 5pm
  // Closed · Open at 6am
  function formatOpenNowString(hoursData, utcOffset) {
    const now = getYextTimeWithUtcOffset(utcOffset);

    const tomorrow = new Date(now.getTime() + 60 * 60 * 24 * 1000);
    const yesterday = new Date(now.getTime() - 60 * 60 * 24 * 1000);
    const nowTimeNumber = now.getHours() + now.getMinutes() / 60;

    function getIntervalOnDate(date) {
      const day = date.getDate();
      const month = date.getMonth() + 1;
      const year = date.getFullYear();

      const days = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday",
      ];

      const dateString =
        year +
        "-" +
        (month < 10 ? "0" + month : month) +
        "-" +
        (day < 10 ? "0" + day : day);
      const dayOfWeekString = days[date.getDay()];

      // Check for holiday
      if (hoursData.holidayHours) {
        for (let i = 0; i < hoursData.holidayHours.length; i++) {
          const holiday = hoursData.holidayHours[i];
          if (holiday.date == dateString) {
            if (holiday.openIntervals) {
              return holiday.openIntervals;
            } else if (holiday.isClosed === true) {
              return null; // On holiday but closed
            }
          }
        }
      }

      // Not on holiday
      if (
        hoursData[dayOfWeekString] &&
        hoursData[dayOfWeekString].openIntervals
      ) {
        return hoursData[dayOfWeekString].openIntervals;
      } else {
        return null;
      }
    }
    const intervalsToday = getIntervalOnDate(now);
    const intervalsTomorrow = getIntervalOnDate(tomorrow);
    const intervalsYesterday = getIntervalOnDate(yesterday);
    let openRightNow = false;
    let currentInterval = null;
    let nextInterval = null;

    if (intervalsYesterday) {
      for (let i = 0; i < intervalsYesterday.length; i++) {
        const interval = intervalsYesterday[i];
        const startIntervalNumber = timeStringToNumber(interval.start);
        const endIntervalNumber = timeStringToNumber(interval.end);

        // If end overflows to the next day (i.e. today).
        if (endIntervalNumber < startIntervalNumber) {
          if (nowTimeNumber < endIntervalNumber) {
            currentInterval = interval;
            openRightNow = true;
          }
        }
      }
    }

    // Assumes no overlapping intervals
    if (intervalsToday) {
      for (let i = 0; i < intervalsToday.length; i++) {
        const interval = intervalsToday[i];
        const startIntervalNumber = timeStringToNumber(interval.start);
        const endIntervalNumber = timeStringToNumber(interval.end);

        // If current time doesn't belong to one of yesterdays interval.
        if (currentInterval == null) {
          if (endIntervalNumber < startIntervalNumber) {
            if (nowTimeNumber >= startIntervalNumber) {
              currentInterval = interval;
              openRightNow = true;
            }
          } else if (
            nowTimeNumber >= startIntervalNumber &&
            nowTimeNumber < endIntervalNumber
          ) {
            currentInterval = interval;
            openRightNow = true;
          }
        }

        if (nextInterval == null) {
          if (startIntervalNumber > nowTimeNumber) {
            nextInterval = interval;
          }
        } else {
          if (
            startIntervalNumber > nowTimeNumber &&
            startIntervalNumber < timeStringToNumber(nextInterval.start)
          ) {
            nextInterval = interval;
          }
        }
      }
    }

    let nextIsTomorrow = false;

    // If no more intervals in the day
    if (nextInterval == null) {
      if (intervalsTomorrow) {
        if (intervalsTomorrow.length > 0) {
          nextInterval = intervalsTomorrow[0];
          nextIsTomorrow = true;
        }
      }
    }

    let hoursString = "";

    function formatTime(time) {
      const tempDate = new Date("January 1, 2020 " + time);
      const localeString = "en-US";
      const tempTime = tempDate.toLocaleTimeString(
        localeString.replace("_", "-"),
        { hour: "numeric", minute: "numeric" }
      );
      return tempTime;
    }

    if (nextInterval) {
      if (openRightNow) {
        // Check first for a 24-hour interval, then check for open past midnight
        if (currentInterval.start == "00:00" && currentInterval.end == "23:59") {
          hoursString += "<strong>Open 24 hours</strong>";
        } else if (
          nextInterval.start == "00:00" &&
          currentInterval.end == "23:59"
        ) {
          hoursString +=
            "<strong>Open</strong> · Closes at [closingTime] tomorrow";
          hoursString = hoursString.replace(
            "[closingTime]",
            formatTime(currentInterval.end)
          );
        } else {
          hoursString += "<strong>Open</strong> · Closes at [closingTime]";
          hoursString = hoursString.replace(
            "[closingTime]",
            formatTime(currentInterval.end)
          );
        }
      } else {
        if (nextIsTomorrow) {
          hoursString +=
            "<strong>Closed</strong> · Opens at [openingTime] tomorrow";
          hoursString = hoursString.replace(
            "[openingTime]",
            formatTime(nextInterval.start)
          );
        } else {
          hoursString += "<strong>Closed</strong> · Opens at [openingTime]";
          hoursString = hoursString.replace(
            "[openingTime]",
            formatTime(nextInterval.start)
          );
        }
      }
    }

    return hoursString;
  }

  function getValueFromPath(object, path) {
    return path.split(".").reduce(function (obj, pth) {
      return typeof obj == "undefined" || obj == null ? null : obj[pth];
    }, object);
  }

  function processParameterizedRichTextContentMapping(entityProfile, mapping) {

    const fieldValue = getValueFromPath(entityProfile, mapping);
    return mapping.isRtf ? RtfConverter.toHTML(fieldValue) : fieldValue;
  }

  function getYextTimeWithUtcOffset(entityUtcOffsetSeconds) {
    const now = new Date();
    let utcOffset = 0;
    if (entityUtcOffsetSeconds) {
      utcOffset = entityUtcOffsetSeconds * 1000;
    }
    if (utcOffset !== 0) {
      const localUtcOffset = now.getTimezoneOffset() * 60 * 1000;
      return new Date(now.valueOf() + utcOffset + localUtcOffset);
    }
    return now;
  }

  // Parses an offset formatted like {+/-}{04}:{00}
  function parseTimeZoneUtcOffset(timeString) {
    if (!timeString) {
      return 0;
    }
    const parts = timeString.split(":");
    const hours = parseInt(parts[0].replace(/\u200E/g, ""), 10);
    const minutes = parseInt(parts[1].replace(/\u200E/g, ""), 10);
    if (hours < 0) {
      return -(Math.abs(hours) + minutes / 60) * 60 * 60;
    }
    return (hours + minutes / 60) * 60 * 60;
  }

  function locationJSONtoHTML(entityProfile, index, locationOptions) {
    const cardTitleValue =
      locationOptions.cardTitle.contentSource === "FIELD"
        ? processParameterizedRichTextContentMapping(
            entityProfile,
            locationOptions.cardTitle.value
          )
        : locationOptions.cardTitle.value.value;

    const getDirectionsLabelValue =
      locationOptions.getDirectionsLabel.contentSource === "FIELD"
        ? processParameterizedRichTextContentMapping(
            entityProfile,
            locationOptions.getDirectionsLabel.value
          )
        : locationOptions.getDirectionsLabel.value;

    const viewDetailsLinkTextValue =
      locationOptions.viewDetailsLinkText.contentSource === "FIELD"
        ? processParameterizedRichTextContentMapping(
            entityProfile,
            locationOptions.viewDetailsLinkText.value
          )
        : locationOptions.viewDetailsLinkText.value.value;

    let cardTitleLinkUrlValue =
      locationOptions["cardTitleLinkUrl"]["contentSource"] === "FIELD"
        ? getValueFromPath(
            entityProfile,
            locationOptions["cardTitleLinkUrl"]["value"]
          )
        : locationOptions["cardTitleLinkUrl"]["value"];
    const hoursValue =
      locationOptions["hours"]["contentSource"] === "FIELD"
        ? getValueFromPath(entityProfile, locationOptions["hours"]["value"])
        : locationOptions["hours"]["value"];
    const addressValue =
      locationOptions["address"]["contentSource"] === "FIELD"
        ? getValueFromPath(entityProfile, locationOptions["address"]["value"])
        : locationOptions["address"]["value"];
    const phoneNumberValue =
      locationOptions["phoneNumber"]["contentSource"] === "FIELD"
        ? getValueFromPath(entityProfile, locationOptions["phoneNumber"]["value"])
        : locationOptions["phoneNumber"]["value"];
    const availabilityValue =
      locationOptions["availability"]["contentSource"] === "FIELD"
        ? getValueFromPath(entityProfile, locationOptions["availability"]["value"])
        : locationOptions["availability"]["value"];
    let viewDetailsLinkUrlValue =
      locationOptions["viewDetailsLinkUrl"]["contentSource"] === "FIELD"
        ? getValueFromPath(
            entityProfile,
            locationOptions["viewDetailsLinkUrl"]["value"]
          )
        : locationOptions["viewDetailsLinkUrl"]["value"];

    let html =
      '<div class="lp-param-results lp-subparam-cardTitle lp-subparam-cardTitleLinkUrl">';
    if (cardTitleLinkUrlValue && cardTitleValue) {
      if (cardTitleLinkUrlValue["url"]) {
        cardTitleLinkUrlValue = cardTitleLinkUrlValue["url"];
      }
      html +=
        '<div class="name hover:underline hover:font-semibold text-ll-red ">' +
        '<a href="'  +
        cardTitleLinkUrlValue +
        '">' +
        cardTitleValue +
        "</a></div>";
    } else if (cardTitleValue) {
      html += '<div class="name hover:underline hover:font-semibold text-ll-red ">' + cardTitleValue + "</div>";
    }
    html += "</div>";

    if (hoursValue) {
      const offset = getValueFromPath(entityProfile, "timeZoneUtcOffset");
      const parsedOffset = parseTimeZoneUtcOffset(offset);
      html += '<div class="lp-param-results lp-subparam-hours">';
      html +=
        '<div class="open-now-string">' +
        formatOpenNowString(hoursValue, parsedOffset) +
        "</div>";
      html += "</div>";
    }

    const localeString = "en-US";
    html += i18n.addressForCountry({
      locale: localeString,
      profile: { address: addressValue },
      regionAbbr: false,
      derivedData: { address: addressValue },
    });

    html += '<div class="lp-param-results lp-subparam-phoneNumber">';
    if (phoneNumberValue) {
      const formattedPhoneNumber = formatPhone(
        phoneNumberValue,
        addressValue.countryCode
      );
      if (formattedPhoneNumber) {
        html += '<div class="phone">' + formattedPhoneNumber + "</div>";
      }
    }
    html += "</div>";

    const singleLineAddress =
      entityProfile.name +
      " " +
      addressValue.line1 +
      " " +
      (addressValue.line2 ? addressValue.line2 + " " : "") +
      addressValue.city +
      " " +
      addressValue.region +
      " " +
      addressValue.postalCode;
    html += '<div class="lp-param-results lp-subparam-getDirectionsLabel">';
    html +=
      '<div class="link"><a target="_blank" href="https://www.google.com/maps/dir/?api=1&destination=' +
      singleLineAddress +
      '">' +
      getDirectionsLabelValue +
      "</a></div>";
    html += "</div>";
    html += '<div class="lp-param-results lp-subparam-availability mt-3">';
    if (availabilityValue) {
        html += '<div class="availability">' + "<strong>Limited Availability</strong>" + "</div>";
    }
    html += "</div>";

    if (viewDetailsLinkUrlValue && viewDetailsLinkTextValue) {
      // Url value is URL object and not url.
      if (viewDetailsLinkUrlValue["url"]) {
        viewDetailsLinkUrlValue = viewDetailsLinkUrlValue["url"];
      }
      html +=
        '<div class="lp-param-results lp-subparam-viewDetailsLinkText lp-subparam-viewDetailsLinkUrl">';
      html +=
        '<div class="lp-param lp-param-viewDetailsLabel link"><strong><a href="' +
        viewDetailsLinkUrlValue +
        '">' +
        viewDetailsLinkTextValue +
        "</a></strong></div>";
      html += "</div>";
    }

    // Add center column
    html = '<div class="center-column">' + html + "</div>";

    // Add left and right column
    if (entityProfile.__distance) {
      html =
        '<div class="left-column">' +
        (index + 1) +
        ".</div>" +
        html +
        '<div class="right-column"><div class="distance">' +
        formatMiOrKm(
          entityProfile.__distance.distanceMiles,
          entityProfile.__distance.distanceKilometers
        ) +
        "</div></div>";
    }

    return (
      '<div class="result" onmouseenter="highlightLocation(' +
      index +
      ', false, false)" onclick="highlightLocation(' +
      index +
      ', false, true)">' +
      html +
      "</div>"
    );
  }

  // Renders each location the the result-list-inner html
  function renderLocations(locations, append, viewMore) {
    if (!append) {
      [].slice
        .call(document.querySelectorAll(".result-list-inner") || [])
        .forEach(function (el) {
          el.innerHTML = "";
        });
    }

    for (var index = 0; index < locations.length; index++) {
      var location = locations[index];
      [].slice
        .call(document.querySelectorAll(".result-list-inner") || [])
        .forEach(function (el) {
          el.innerHTML += locationJSONtoHTML(
            location,
            index,
            getLocationOptions()
          );
        });
    }

    if (viewMore) {
      [].slice
        .call(document.querySelectorAll(".result-list-inner") || [])
        .forEach(function (el) {
          el.innerHTML +=
            '<div><div class="btn btn-link btn-block">View More</div></div>';
        });
    }
  }

  function searchDetailMessageForCityAndRegion(total) {
    if (total === 0) {
      return '0 [locationType] found near <strong>"[city], [region]"</strong>';
    } else {
      return '[formattedVisible] of [formattedTotal] [locationType] near <strong>"[city], [region]"</strong>';
    }
  }

  function searchDetailMessageForArea(total) {
    if (total == 0) {
      return '0 [locationType] found near <strong>"[location]"</strong>';
    } else {
      return '[formattedVisible] of [formattedTotal] [locationType] near <strong>"[location]"</strong>';
    }
  }

  function searchDetailMessageNoGeo(total) {
    if (total === 0) {
      return "0 [locationType]";
    } else {
      return "[formattedVisible] of [formattedTotal] [locationType]";
    }
  }

  // Renders details of the search
  function renderSearchDetail(geo, visible, total, queryString) {
    // x of y locations near "New York, NY"
    // x  locations near "New York, NY"
    // x  locations near "New York, NY"

    let locationType = locationNoun;
    if (total === 0 || total > 1) {
      if (locationNounPlural !== "") {
        locationType = locationNounPlural;
      } else {
        locationType += "s";
      }
    }

    let formattedVisible = formatNumber(visible);
    let formattedTotal = formatNumber(total);

    let searchDetailMessage;
    if (geo) {
      if (geo.address.city !== "") {
        searchDetailMessage = searchDetailMessageForCityAndRegion(total);
        searchDetailMessage = searchDetailMessage.replace(
          "[city]",
          geo.address.city
        );
        searchDetailMessage = searchDetailMessage.replace(
          "[region]",
          geo.address.region
        );
      } else {
        let location = "";
        if (geo.address.region) {
          location = geo.address.region;
        } else if (geo.address.country && queryString) {
          location = queryString;
        } else if (geo.address.country) {
          location = geo.address.country;
        }
        if (location !== "") {
          searchDetailMessage = searchDetailMessageForArea(total);
          searchDetailMessage = searchDetailMessage.replace(
            "[location]",
            location
          );
        }
      }
    } else {
      searchDetailMessage = searchDetailMessageNoGeo(total);
    }
    searchDetailMessage = searchDetailMessage.replace(
      "[locationType]",
      locationType
    );
    searchDetailMessage = searchDetailMessage.replace(
      "[formattedVisible]",
      formattedVisible
    );
    searchDetailMessage = searchDetailMessage.replace(
      "[formattedTotal]",
      formattedTotal
    );

   // [].slice
     // .call(document.querySelectorAll(".search-center") || [])
     // .forEach(function (el) {
     //   el.innerHTML = "";
    //  });
   // [].slice
   //   .call(document.querySelectorAll(".search-center") || [])
   //   .forEach(function (el) {
   //     el.innerHTML = searchDetailMessage;
   //   });
  }

  function getRequest(request_url, queryString) {
    // Add query string to URL
    if (queryString !== null) {
      const newUrl = window.location.href.replace(
        /(\?.*)?$/,
        "?q=queryString".replace("queryString", queryString)
      );
      if (
        window.history.state &&
        window.history.state.queryString !== queryString
      ) {
        window.history.pushState({ queryString: queryString }, "", newUrl);
      } else {
        window.history.replaceState({ queryString: queryString }, "", newUrl);
      }
    }

    startLoading();
    request_url += "&api_key=" + liveAPIKey;
    request_url += "&v=" + "20181201";
    request_url += "&resolvePlaceholders=true";

    if (entityTypes) {
      request_url += "&entityTypes=" + entityTypes;
    }

    if (savedFilterId) {
      request_url += "&savedFilterIds=" + savedFilterId;
    }

    $.ajax({
      url: request_url,
      type: "GET",
      timeout: 5000,
      success: function (data) {
        locations = [];
        for (var i = 0; i < data.response.entities.length; i++) {
          var location = data.response.entities[i];

          // Add location distance if it exists
          if (data.response.distances) {
            location.__distance = data.response.distances[i];
          }
          locations.push(location);
        }
        // Update Panel
        renderLocations(locations, false, false);
        renderSearchDetail(
          data.response.geo,
          locations.length,
          data.response.count,
          queryString
        );

        // Update Map
        addMarkersToMap(locations);

        if (locations.length == 0) {
          centerOnGeo(data.response.geo);
        }
        [].slice
          .call(document.querySelectorAll(".error-text") || [])
          .forEach(function (el) {
            el.textContent = "";
          });
        stopLoading();
      },
      error: function (request, status, error) {
        stopLoading();
        if (request.responseJSON && request.responseJSON.meta.errors.length > 0) {
          alert(request.responseJSON.meta.errors[0]["message"]);
        } else if (status === "timeout") {
          alert(
            "Unable to retrieve results. Please wait a few seconds and" +
              " try again."
          );
        } else {
          alert("Invalid Live API Key");
        }
      },
    });
  }

  window.addEventListener("popstate", function (e) {
    if (e.state && e.state.queryString) {
      locationInput.value = e.state.queryString;
      getNearestLocationsByString();
    }
  });

  window.addEventListener("load", function () {
    const params = getQueryParamsFromUrl();
    const queryString = params["q"] || defaultQuery;
    locationInput.value = decodeURI(queryString);
    getNearestLocationsByString();
  });

  function getQueryParamsFromUrl() {
    let params = {};
    window.location.href.replace(
      /[?&]+([^=&]+)=([^&]*)/gi,
      function (match, key, value) {
        params[key] = decodeURI(value);
      }
    );
    return params;
  }

  function getNearestLocationsByString() {
    const queryString = locationInput.value;
    if (queryString.trim() !== "") {
      var request_url = this.base_url + "entities/geosearch";
      request_url += "?radius=" + radius;
      request_url += "&location=" + queryString;
      request_url += "&limit=" + limit;
      this.getRequest(request_url, queryString);
    } else {
      // Error Message
    }
  }

  // Get locations by lat lng (automatically fired if the user grants acceess)
  function getNearestLatLng(position) {
    [].slice
      .call(document.querySelectorAll(".error-text") || [])
      .forEach(function (el) {
        el.textContent = "";
      });
    currentLatitude = position.coords.latitude;
    currentLongitude = position.coords.longitude;
    var request_url = this.base_url + "entities/geosearch";
    request_url += "?radius=" + radius;
    request_url +=
      "&location=" + position.coords.latitude + ", " + position.coords.longitude;
    request_url += "&limit=" + limit;
    this.getRequest(request_url, null);
  }

  // Gets a list of locations. Only renders if it's a complete list. This avoids a dumb looking map for accounts with a ton of locations.
  function getLocations() {
    var request_url =
      this.base_url +
      "entities" +
      "?limit=" +
      limit +
      '&sortBy=[{"name":"ASCENDING"}]';
    this.getRequest(request_url, null);
  }

  locationInput.addEventListener("keydown", function (e) {
    if (e.keyCode === 13) {
      //checks whether the pressed key is "Enter"
      getNearestLocationsByString();
    }
  });

  function getUsersLocation() {
    if (navigator.geolocation) {
      startLoading();
      function error(error) {
        [].slice
          .call(document.querySelectorAll(".error-text") || [])
          .forEach(function (el) {
            el.textContent =
              "Unable to determine your location. Please try entering a location in the search bar.";
          });
        stopLoading();
      }
      navigator.geolocation.getCurrentPosition(getNearestLatLng, error, {
        timeout: 10000,
      });
    }
  }

  // Map Configuration
  var markers = [];

  function centerOnGeo(geo) {
    var lat, lng;
    if (geo && geo.coordinate) {
      lat = geo.coordinate.latitude;
      lng = geo.coordinate.longitude;
    } else {
      lat = currentLatitude;
      lng = currentLongitude;
    }
    [].slice
      .call(document.querySelectorAll(".error-text") || [])
      .forEach(function (el) {
        el.textContent = "";
      });
    map.setCenter({ lat: lat, lng: lng });
    map.setZoom(7);
  }

  let pinStyles;
  let marker_icon;
  let selected_marker_icon;

  function addMarkersToMap(locations) {
    bounds = new google.maps.LatLngBounds();
    for (let index = 0; index < markers.length; index++) {
      var marker = markers[index];
      marker.setMap(null);
    }
    markers = [];

    const coordinates = { value: "geocodedCoordinate", contentSource: "FIELD" };
    pinStyles = {
      fill: "#fff", //default google red
      stroke: "#fff",
      text: "black",
      fill_selected: "#E52222",
      stroke_selected: "#E52222",
      text_selected: "black",
    };

    marker_icon = {
      // default google pin path
      path: "M 7.75 -37.5 c -4.5 -4 -11 -4 -15.5 0 c -4.5 3.5 -6 10 -3 15 l 5 8.5 c 2.5 4 4.5 8 5 13 l 1 1 l 0.5 -1 s 0 0 0 0 c 0.5 -4.5 2.5 -8.5 5 -12.5 l 5 -9 c 3 -5 1.5 -11.5 -3 -15",
      fillColor: pinStyles.fill,
      scale: 1.1,
      fillOpacity: 1,
      strokeColor: pinStyles.stroke,
      strokeWeight: 1,
      labelOrigin: new google.maps.Point(0, -25),
    };

    selected_marker_icon = {
      path: "M0-48c-9.8 0-17.7 7.8-17.7 17.4 0 15.5 17.7 30.6 17.7 30.6s17.7-15.4 17.7-30.6c0-9.6-7.9-17.4-17.7-17.4z",
      fillColor: pinStyles.fill_selected,
      fillOpacity: 0.8,
      scale: 0.75,
      strokeColor: pinStyles.stroke_selected,
      strokeWeight: 1,
      labelOrigin: new google.maps.Point(0, -25),
    };

    for (let index = 0; index < locations.length; index++) {
      var location = locations[index];
      let coordinatesValue = coordinates["value"];
      coordinatesValue =
        coordinates["contentSource"] === "FIELD"
          ? getValueFromPath(location, coordinatesValue)
          : coordinatesValue;
      if (coordinatesValue) {
        marker = new google.maps.Marker({
          position: {
            lat: coordinatesValue.latitude,
            lng: coordinatesValue.longitude,
          },
          map: map,
          icon: marker_icon,
          label: {
            text: String(index + 1),
            color: pinStyles.text,
          },
          optimized: false,
        });
        selected_marker = new google.maps.Marker({
          position: {
            lat: coordinatesValue.latitude,
            lng: coordinatesValue.longitude,
          },
          map: map,
          icon: selected_marker_icon,
          label: {
            text: String(index + 1),
            color: pinStyles.text_selected,
          },
          optimized: false,
        });

        selected_marker.setVisible(false);

        bounds.extend(marker.position);

        google.maps.event.addListener(marker, "click", function () {
          highlightLocation(index, true, false);
        });

        google.maps.event.addListener(selected_marker, "click", function () {
          highlightLocation(index, true, false);
        });

        google.maps.event.addListener(marker, "mouseover", function () {
          highlightLocation(index, false, false);
        });

        markers.push(marker);
      }
    }

    map.fitBounds(bounds);
  }

  function scrollToRow(index) {
    let result = [].slice.call(document.querySelectorAll(".result") || [])[0];
    let offset =
      [].slice.call(document.querySelectorAll(".result") || [])[index].offsetTop -
      result.offsetTop;
    [].slice
      .call(document.querySelectorAll(".result-list") || [])
      .forEach(function (el) {
        el.scrollTop = offset;
      });
  }

  function highlightLocation(index, shouldScrollToRow, shouldCenterMap) {
    if (selectedLocationIndex == index) {
      // No Change (just center map or scroll)
      if (shouldCenterMap) {
        map.setCenter(marker.position);
      }

      if (shouldScrollToRow) {
        scrollToRow(index);
      }
    } else {
      const prevIndex = selectedLocationIndex;
      selectedLocationIndex = index;

      [].slice
        .call(document.querySelectorAll(".result") || [])
        .forEach(function (el) {
          el.classList.remove("selected");
        });
      [].slice.call(
        document.querySelectorAll(".result")[index].classList.add("selected") ||
          []
      );

      if (shouldScrollToRow) {
        scrollToRow(index);
      }

      // Update Map
      if (prevIndex !== -1) {
        const prevMarker = markers[prevIndex];
        // Breifly disables mouseevents to prevent infinite mouseover looping for overlapped markers
        prevMarker.setClickable(false);
        prevMarker.setIcon(marker_icon);
        prevMarker.setLabel({
          text: String(prevIndex + 1),
          color: pinStyles.text,
        });
        prevMarker.setZIndex(null);

        setTimeout(function () {
          prevMarker.setClickable(true);
        }, 50);
      }

      const selectedMarker = markers[selectedLocationIndex];
      selectedMarker.setIcon(selected_marker_icon);
      selectedMarker.setLabel({
        text: String(selectedLocationIndex + 1),
        color: pinStyles.text_selected,
      });
      selectedMarker.setZIndex(999);

      if (shouldCenterMap) {
        map.setCenter(marker.position);
      }
    }
  }

  // Autocomplete
  function autocompleteChanged() {
    // Clicked result
    if (!isLoading) {
      getNearestLocationsByString();
    }
  }

  function hexToRgb(hex) {
    const m = hex.match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
    return {
      r: parseInt(m[1], 16),
      g: parseInt(m[2], 16),
      b: parseInt(m[3], 16),
    };
  }

  // Postive values >> lighten
  // Negative values >> darken
  function changeColor(hex, amt) {
    const rgb = hexToRgb(hex);

    Object.keys(rgb).forEach(function (key) {
      let c = rgb[key];
      // Add amt to color value, min/max at 0/255
      c += amt;
      if (c > 255) c = 255;
      else if (c < 0) c = 0;

      // Convert RGB value back to hex string
      rgb[key] =
        c.toString(16).length == 1 ? "0" + c.toString(16) : c.toString(16);
    });

    return "#" + rgb.r + rgb.g + rgb.b;
  }

  function getCustomPinColor(hex) {
    // Converts hex to RGB values
    const rgb = hexToRgb(hex);

    // Calcs perceived brightness using the sRGB Luma method
    const lightness = (rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722) / 255;
    const isDark = lightness < 0.5;

    if (isDark) {
      return {
        fill: hex,
        stroke: "#fff",
        text: "#fff",
        fill_selected: changeColor(hex, 150),
        stroke_selected: hex,
        text_selected: "#000",
      };
    } else {
      const darker = changeColor(hex, -150);
      return {
        fill: hex,
        stroke: darker,
        text: "#000",
        fill_selected: darker,
        stroke_selected: "#fff",
        text_selected: "#fff",
      };
    }
  }

  if (loadLocationsOnLoad) {
    getLocations();
  }

</script>
<script>
    var zoom = 5;    
    var map;
    console.log(zoom);
    map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: 40.693807, lng: 73.9917 },
    zoom: zoom,
    styles: [
      { elementType: "geometry", stylers: [{ color: "#242f3e" }] },
      { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] },
      { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
      {
        featureType: "administrative.locality",
        elementType: "labels.text.fill",
        stylers: [{ color: "#d59563" }],
      },
      {
        featureType: "poi",
        elementType: "labels",
        stylers: [{ visibility: "off" }],
      },
      {
        featureType: "poi",
        elementType: "geometry",
        stylers: [{ visibility: "off" }],
      },
      {
        featureType: "road",
        elementType: "geometry",
        stylers: [{ color: "#38414e" }],
      },
      {
        featureType: "road",
        elementType: "geometry.stroke",
        stylers: [{ color: "#212a37" }],
      },
      {
        featureType: "road",
        elementType: "labels.text.fill",
        stylers: [{ color: "#9ca5b3" }],
      },
      {
        featureType: "road.highway",
        elementType: "geometry",
        stylers: [{ color: "#746855" }],
      },
      {
        featureType: "road.highway",
        elementType: "geometry.stroke",
        stylers: [{ color: "#1f2835" }],
      },
      {
        featureType: "road.highway",
        elementType: "labels.text.fill",
        stylers: [{ color: "#f3d19c" }],
      },
      {
        featureType: "transit",
        elementType: "geometry",
        stylers: [{ color: "#2f3948" }],
      },
      {
        featureType: "transit.station",
        elementType: "labels.text.fill",
        stylers: [{ color: "#d59563" }],
      },
      {
        featureType: "water",
        elementType: "geometry",
        stylers: [{ color: "#17263c" }],
      },
      {
        featureType: "water",
        elementType: "labels.text.fill",
        stylers: [{ color: "#515c6d" }],
      },
      {
        featureType: "water",
        elementType: "labels.text.stroke",
        stylers: [{ color: "#17263c" }],
      },
    ],
    mapTypeControl: false,
    });

    if (enableAutocomplete) {
    autocomplete = new google.maps.places.Autocomplete(document.getElementById('location-input'), {
        options: {
        types: ['(regions)'],
        }
    });
    autocomplete.addListener('place_changed', autocompleteChanged);
    }
</script>

<script>
    /**
 * @name MarkerWithLabel for V3
 * @version 1.2.3
 * @author Gary Little (inspired by code from Marc Ridey of Google).
 * @copyright Copyright 2012 Gary Little [gary at luxcentral.com]
 * @fileoverview MarkerWithLabel extends the Google Maps JavaScript API V3
 *  <code>google.maps.Marker</code> class.
 *  <p>
 *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,
 *  if the marker is draggable, so too will be the label. In addition, a marker with a label
 *  responds to all mouse events in the same manner as a regular marker. It also fires mouse
 *  events and "property changed" events just as a regular marker would.
 */

/*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint browser:true */
/*global document,google */

/**
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 * @private
 */
function inherits(childCtor, parentCtor) {
  /* @constructor */
  function tempCtor() {}
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /* @override */
  childCtor.prototype.constructor = childCtor;
}

/**
 * This constructor creates a label and associates it with a marker.
 * It is for the private use of the MarkerWithLabel class.
 * @constructor
 * @param {Marker} marker The marker with which the label is to be associated.
 * @param {string} crossURL The URL of the cross image =.
 * @private
 */
function MarkerLabel_(marker, crossURL) {
  this.marker_ = marker;

  this.labelDiv_ = document.createElement("div");
  this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";

  // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil
  // in the "overlayMouseTarget" pane, a veil that covers just the label. This is done so that
  // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.
  // Code is included here to ensure the veil is always exactly the same size as the label.
  this.eventDiv_ = document.createElement("div");
  this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;

  // This is needed for proper behavior on MSIE:
  this.eventDiv_.setAttribute("onselectstart", "return false;");
  this.eventDiv_.setAttribute("ondragstart", "return false;");

  // Get the DIV for the "X" to be displayed when the marker is raised.
  this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
}

if (typeof google !== 'undefined') {
  inherits(MarkerLabel_, google.maps.OverlayView);
}


/**
 * Returns the DIV for the cross used when dragging a marker when the
 * crossOnDrag parameter set to true. One cross is shared with all markers.
 * @param {string} crossURL The URL of the cross image.
 * @private
 */
MarkerLabel_.getSharedCross = function (crossURL) {
  var div;
  if (typeof MarkerLabel_.getSharedCross.crossDiv === "undefined") {
    div = document.createElement("img");
    div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
    // Hopefully Google never changes the standard "X" attributes:
    div.style.marginLeft = "-8px";
    div.style.marginTop = "-9px";
    div.src = crossURL;
    MarkerLabel_.getSharedCross.crossDiv = div;
  }
  return MarkerLabel_.getSharedCross.crossDiv;
};

/**
 * Adds the DIV representing the label to the DOM. This method is called
 * automatically when the marker's <code>setMap</code> method is called.
 * @private
 */
MarkerLabel_.prototype.onAdd = function () {
  var me = this;

  this.getPanes().markerLayer.appendChild(this.labelDiv_);
  this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
  // One cross is shared with all markers, so only add it once:
  if (typeof MarkerLabel_.getSharedCross.processed === "undefined") {
    this.getPanes().overlayImage.appendChild(this.crossDiv_);
    MarkerLabel_.getSharedCross.processed = true;
  }

  this.addMouseListeners();

  this.listeners2_ = [
    google.maps.event.addListener(this.marker_, "clickable_changed", function () {
      me.setClickable();
    }),
    google.maps.event.addListener(this.marker_, "cursor_changed", function () {
      me.setCursor();
    }),
    google.maps.event.addListener(this.marker_, "draggable_changed", function () {
      me.setClickable();
    }),
    google.maps.event.addListener(this.marker_, "position_changed", function () {
      me.setPosition();
    }),
    google.maps.event.addListener(this.marker_, "visible_changed", function () {
      me.setVisible();
    }),
    google.maps.event.addListener(this.marker_, "title_changed", function () {
      me.setTitle();
    }),
    google.maps.event.addListener(this.marker_, "zindex_changed", function () {
      me.setZIndex();
    }),
    google.maps.event.addListener(this.marker_, "labelanchor_changed", function () {
      me.setAnchor();
    }),
    google.maps.event.addListener(this.marker_, "labelclass_changed", function () {
      me.setStyles();
    }),
    google.maps.event.addListener(this.marker_, "labelcontent_changed", function () {
      me.setContent();
    }),
    google.maps.event.addListener(this.marker_, "labelstyle_changed", function () {
      me.setStyles();
    }),
    google.maps.event.addListener(this.marker_, "labelvisible_changed", function () {
      me.setVisible();
    })
  ];
};

/**
 * Adds the listeners for a clickable label.
 * @private
 */
MarkerLabel_.prototype.addMouseListeners = function () {
  var me = this;
  var cTouchScreen = false;
  var cMouseIsDown = false;
  var cDraggingLabel = false;
  var cIgnoreClick;
  var cLatOffset, cLngOffset;

  // Stop all processing of an event.
  //
  var cAbortEvent = function (e) {
    e = e || window.event;
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  };

  // Stop an event from propagating.
  //
  var cStopPropagation = function (e) {
    e = e || window.event;
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  };

  this.listeners1_ = [
    google.maps.event.addDomListener(this.eventDiv_, "mouseover", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      if (me.marker_.getClickable() || me.marker_.getDraggable()) {
        if (!cTouchScreen) {
          this.style.cursor = (me.marker_.getCursor() || "pointer");
          google.maps.event.trigger(me.marker_, "mouseover", mEvent);
          cAbortEvent(e);
        }
      } else {
        this.style.cursor = null;
      }
    }),
    google.maps.event.addDomListener(this.eventDiv_, "mouseout", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      if (me.marker_.getClickable() || me.marker_.getDraggable()) {
        if (!cTouchScreen) {
          google.maps.event.trigger(me.marker_, "mouseout", mEvent);
          cAbortEvent(e);
        }
      }
    }),
    google.maps.event.addDomListener(this.eventDiv_, "mousedown", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      cDraggingLabel = false;
      if (me.marker_.getClickable() || me.marker_.getDraggable()) {
        cMouseIsDown = true;
        google.maps.event.trigger(me.marker_, "mousedown", mEvent);
        if (!cTouchScreen) {
          cAbortEvent(e); // Prevent map pan when starting a drag on a label
        }
      }
    }),
    google.maps.event.addDomListener(this.eventDiv_, "mouseup", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      if (cMouseIsDown) {
        cMouseIsDown = false;
        google.maps.event.trigger(me.marker_, "mouseup", mEvent);
        if (cDraggingLabel) {
          cDraggingLabel = false;
          me.crossDiv_.style.display = "none";
          cIgnoreClick = true; // Set flag to ignore the click event reported after a label drag
          google.maps.event.trigger(me.marker_, "dragend", mEvent);
        }
        if (!me.marker_.getDraggable()) {
          cAbortEvent(e);
        }
      }
    }),
    google.maps.event.addDomListener(this.eventDiv_, "click", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      if (me.marker_.getClickable() || me.marker_.getDraggable()) {
        if (cIgnoreClick) { // Ignore the click reported when a label drag ends
          cIgnoreClick = false;
        } else {
          google.maps.event.trigger(me.marker_, "click", mEvent);
        }
        cAbortEvent(e); // Prevent click from being passed on to map
      }
    }),
    google.maps.event.addDomListener(this.eventDiv_, "dblclick", function (e) {
      var mEvent = {latLng: me.marker_.getPosition()};
      if (me.marker_.getClickable() || me.marker_.getDraggable()) {
        google.maps.event.trigger(me.marker_, "dblclick", mEvent);
        cAbortEvent(e); // Prevent map zoom when double-clicking on a label
      }
    }),
    google.maps.event.addListener(this.marker_.getMap(), "mousemove", function (mEvent) {
      var position;
      if (cMouseIsDown && me.marker_.getDraggable()) {
        if (cDraggingLabel) {
          // Change the reported location from the mouse position to the marker position:
          mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
          if (me.marker_.get("crossOnDrag")) { // Position and display the cross
            position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
            me.crossDiv_.style.left = position.x + "px";
            me.crossDiv_.style.top = position.y + "px";
            me.crossDiv_.style.display = "";
          }
          google.maps.event.trigger(me.marker_, "drag", mEvent);
        } else {
          // Calculate offsets from the click point to the marker position:
          cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
          cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
          cDraggingLabel = true;
          mEvent.latLng = me.marker_.getPosition();
          google.maps.event.trigger(me.marker_, "dragstart", mEvent);
        }
      }
    }),
    google.maps.event.addListener(this.marker_, "dragstart", function (mEvent) {
      // During a drag, the marker's z-index is temporarily set to 1000000 to ensure
      // it appears above all other markers. Here we also set the label's z-index
      // to 1000000 (plus or minus 1 depending on whether the label is supposed
      // to be above or below the marker). (NOTE: For some reason, Google does not
      // fire a zindex_changed event when changing the marker's z-index to 100000
      // or else this task would be handled by the MarkerLabel_.setZIndex() method.)
      //
      me.labelDiv_.style.zIndex = 1000000 + (this.get("labelInBackground") ? -1 : +1);
      me.eventDiv_.style.zIndex = me.labelDiv_.style.zIndex;
    }),
    google.maps.event.addListener(this.marker_, "drag", function (mEvent) {
      this.setPosition(mEvent.latLng);
    }),
    google.maps.event.addListener(this.marker_, "dragend", function (mEvent) {
      me.setZIndex();
    }),
    // Prevent touch events from passing through the label DIV to the underlying map.
    //
    google.maps.event.addDomListener(this.eventDiv_, "touchstart", function (e) {
      cTouchScreen = true;
      cStopPropagation(e);
    }),
    google.maps.event.addDomListener(this.eventDiv_, "touchmove", function (e) {
      cStopPropagation(e);
    }),
    google.maps.event.addDomListener(this.eventDiv_, "touchend", function (e) {
      cStopPropagation(e);
    })
  ];
};

/**
 * Removes the listeners for a clickable label.
 * @private
 */
MarkerLabel_.prototype.removeMouseListeners = function () {
  var i;

  if (this.listeners1_) {
    for (i = 0; i < this.listeners1_.length; i++) {
      google.maps.event.removeListener(this.listeners1_[i]);
    }
  }
};

/**
 * Removes the DIV for the label from the DOM. It also removes all event handlers.
 * This method is called automatically when the marker's <code>setMap(null)</code>
 * method is called.
 * @private
 */
MarkerLabel_.prototype.onRemove = function () {
  var i;
  if (this.labelDiv_.parentNode) {
    this.labelDiv_.parentNode.removeChild(this.labelDiv_);
  }
  if (this.eventDiv_.parentNode) {
    this.eventDiv_.parentNode.removeChild(this.eventDiv_);
  }
  // Remove event listeners:
  this.removeMouseListeners();

  if (this.listeners2_) {
    for (i = 0; i < this.listeners2_.length; i++) {
      google.maps.event.removeListener(this.listeners2_[i]);
    }
  }
};

/**
 * Draws the label on the map.
 * @private
 */
MarkerLabel_.prototype.draw = function () {
  this.setContent();
  this.setTitle();
  this.setStyles();
};

/**
 * Sets the content of the label.
 * The content can be plain text or an HTML DOM node.
 * @private
 */
MarkerLabel_.prototype.setContent = function () {
  var content = this.marker_.get("labelContent");
  var previousContent = this.marker_._previousContent;
  if(previousContent !== content){
    this.marker_._previousContent = content;
    if (typeof content.nodeType === "undefined") {
      this.labelDiv_.innerHTML = content;
      this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
    } else {
      this.labelDiv_.innerHTML = ""; // Remove current content
      this.labelDiv_.appendChild(content);
      content = content.cloneNode(true);
      this.eventDiv_.innerHTML = ""; // Remove current content
      this.eventDiv_.appendChild(content);
    }
  }
};

/**
 * Sets the content of the tool tip for the label. It is
 * always set to be the same as for the marker itself.
 * @private
 */
MarkerLabel_.prototype.setTitle = function () {
  this.eventDiv_.title = this.marker_.getTitle() || "";
};

/**
 * Sets the style of the label by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
MarkerLabel_.prototype.setStyles = function () {
  var i, labelStyle;

  // Apply style values from the style sheet defined in the labelClass parameter:
  this.labelDiv_.className = this.marker_.get("labelClass");
  this.eventDiv_.className = this.labelDiv_.className;

  // Clear existing inline style values:
  this.labelDiv_.style.cssText = "";
  this.eventDiv_.style.cssText = "";
  // Apply style values defined in the labelStyle parameter:
  labelStyle = this.marker_.get("labelStyle");
  for (i in labelStyle) {
    if (labelStyle.hasOwnProperty(i)) {
      this.labelDiv_.style[i] = labelStyle[i];
      this.eventDiv_.style[i] = labelStyle[i];
    }
  }
  this.setMandatoryStyles();
};

/**
 * Sets the mandatory styles to the DIV representing the label as well as to the
 * associated event DIV. This includes setting the DIV position, z-index, and visibility.
 * @private
 */
MarkerLabel_.prototype.setMandatoryStyles = function () {
  this.labelDiv_.style.position = "absolute";
  this.labelDiv_.style.overflow = "hidden";
  // Make sure the opacity setting causes the desired effect on MSIE:
  if (typeof this.labelDiv_.style.opacity !== "undefined" && this.labelDiv_.style.opacity !== "") {
    this.labelDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")\"";
    this.labelDiv_.style.filter = "alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")";
  }

  this.eventDiv_.style.position = this.labelDiv_.style.position;
  this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
  this.eventDiv_.style.cursor = "pointer"; // Required to make this clickable on iOS
  this.eventDiv_.style.opacity = 0.01; // Don't use 0; DIV won't be clickable on MSIE
  this.eventDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\"";
  this.eventDiv_.style.filter = "alpha(opacity=1)"; // For MSIE

  this.setAnchor();
  this.setPosition();
  this.setZIndex();
  this.setVisible();
};

/**
 * Sets the anchor point of the label.
 * @private
 */
MarkerLabel_.prototype.setAnchor = function () {
  var anchor = this.marker_.get("labelAnchor");
  this.labelDiv_.style.marginLeft = -anchor.x + "px";
  this.labelDiv_.style.marginTop = -anchor.y + "px";
  this.eventDiv_.style.marginLeft = -anchor.x + "px";
  this.eventDiv_.style.marginTop = -anchor.y + "px";
};

/**
 * Sets the position of the label. The z-index is also updated, if necessary.
 * @private
 */
MarkerLabel_.prototype.setPosition = function () {
  var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
  this.labelDiv_.style.left = Math.round(position.x) + "px";
  this.labelDiv_.style.top = Math.round(position.y) + "px";
  this.eventDiv_.style.left = this.labelDiv_.style.left;
  this.eventDiv_.style.top = this.labelDiv_.style.top;
};

/**
 * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index
 * of the label is set to the vertical coordinate of the label. This is in keeping with the default
 * stacking order for Google Maps: markers to the south are in front of markers to the north.
 * @private
 */
MarkerLabel_.prototype.setZIndex = function () {
  var zAdjust = (this.marker_.get("labelInBackground") ? -1 : +1);
  if (typeof this.marker_.getZIndex() === "undefined") {
    this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
  } else {
    this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
  }
};

/**
 * Sets the clickability of the label. The label is clickable only if the
 * marker itself is clickable (i.e., its clickable property is true) or if
 * it is draggable (i.e., its draggable property is true).
 * @private
 */
MarkerLabel_.prototype.setClickable = function () {
  this.removeMouseListeners();
  this.eventDiv_.style.cursor = null;
  if (this.marker_.getClickable() || this.marker_.getDraggable()) {
    this.addMouseListeners();
  }
};

/**
 * Sets the cursor for the label.
 * @private
 */
MarkerLabel_.prototype.setCursor = function () {
  this.eventDiv_.style.cursor = this.marker_.getCursor();
};

/**
 * Sets the visibility of the label. The label is visible only if the marker itself is
 * visible (i.e., its visible property is true) and the labelVisible property is true.
 * @private
 */
MarkerLabel_.prototype.setVisible = function () {
  if (this.marker_.get("labelVisible")) {
    this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none";
  } else {
    this.labelDiv_.style.display = "none";
  }
  this.eventDiv_.style.display = this.labelDiv_.style.display;
};

/**
 * @name MarkerWithLabelOptions
 * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.
 *  The properties available are the same as for <code>google.maps.Marker</code> with the addition
 *  of the properties listed below. To change any of these additional properties after the labeled
 *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.
 *  <p>
 *  When any of these properties changes, a property changed event is fired. The names of these
 *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.
 *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event
 *  is fired.
 *  <p>
 * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).
 * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so
 *  that its top left corner is positioned at the anchor point of the associated marker. Use this
 *  property to change the anchor point of the label. For example, to center a 50px-wide label
 *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.
 *  (Note: x-values increase to the right and y-values increase to the top.)
 * @property {string} [labelClass] The name of the CSS class defining the styles for the label.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {Object} [labelStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the label. Style values defined here override those that may
 *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the
 *  label has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the label before the new style values are applied.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its
 *  associated marker should appear in the background (i.e., in a plane below the marker).
 *  The default is <code>false</code>, which causes the label to appear in the foreground.
 * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.
 *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is
 *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also
 *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).
 * @property {boolean} [crossOnDrag] A flag indicating whether a cross ("X") is to be
 *  shown when the marker label is dragged. The default is <code>true</code>. The marker
 *  is placed at the position of the cross when the drag ends.
 * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized
 *  for the marker. <b>Important: The optimized rendering technique is not supported by
 *  MarkerWithLabel, so the value of this parameter is always forced to <code>false</code>.
 * @property {string} [crossImage="//maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png"]
 *  The URL of the cross image to be displayed while dragging a marker.
 */
/**
 * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.
 * @constructor
 * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.
 */
function MarkerWithLabel(opt_options) {
  opt_options = opt_options || {};
  opt_options.labelContent = opt_options.labelContent || "";
  opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
  opt_options.labelClass = opt_options.labelClass || "markerLabels";
  opt_options.labelStyle = opt_options.labelStyle || {};
  opt_options.labelInBackground = opt_options.labelInBackground || false;
  if (typeof opt_options.labelVisible === "undefined") {
    opt_options.labelVisible = true;
  }
  if (typeof opt_options.crossOnDrag === "undefined") {
    opt_options.crossOnDrag = true;
  }
  if (typeof opt_options.clickable === "undefined") {
    opt_options.clickable = true;
  }
  if (typeof opt_options.draggable === "undefined") {
    opt_options.draggable = false;
  }
  if (typeof opt_options.optimized === "undefined") {
    opt_options.optimized = false;
  }
  opt_options.crossImage = opt_options.crossImage || "//maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
  opt_options.optimized = false; // Optimized rendering is not supported

  this.label = new MarkerLabel_(this, opt_options.crossImage); // Bind the label to the marker

  // Call the parent constructor. It calls Marker.setValues to initialize, so all
  // the new parameters are conveniently saved and can be accessed with get/set.
  // Marker.set triggers a property changed event (called "propertyname_changed")
  // that the marker label listens for in order to react to state changes.
  google.maps.Marker.apply(this, arguments);
}

if (typeof google !== 'undefined') {
  inherits(MarkerWithLabel, google.maps.Marker);
}

/**
 * Overrides the standard Marker setMap function.
 * @param {Map} theMap The map to which the marker is to be added.
 * @private
 */
MarkerWithLabel.prototype.setMap = function (theMap) {

  // Call the inherited function...
  google.maps.Marker.prototype.setMap.apply(this, arguments);

  // ... then deal with the label:
  this.label.setMap(theMap);
};

if (typeof module == 'object') {
  module.exports = MarkerWithLabel;
}


// This code was automatically generated. Please don't edit this code by hand.

/**
 * ***********************************************************************
 * ------------------------ GENERATED CODE BEGINS ------------------------
 * ***********************************************************************
 */

if (typeof i18n == 'undefined') { var i18n = {}; }

i18n.addressForCountry = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.profile.address.countryCode) {
    case 'AD':
    case 'AM':
    case 'AX':
    case 'AZ':
    case 'BA':
    case 'BL':
    case 'BY':
    case 'CY':
    case 'CZ':
    case 'DK':
    case 'DZ':
    case 'EC':
    case 'EH':
    case 'ET':
    case 'FI':
    case 'FO':
    case 'FR':
    case 'GE':
    case 'GF':
    case 'GI':
    case 'GP':
    case 'GW':
    case 'HT':
    case 'KG':
    case 'KV':
    case 'KW':
    case 'LA':
    case 'LU':
    case 'MC':
    case 'MD':
    case 'ME':
    case 'MG':
    case 'MK':
    case 'MQ':
    case 'MZ':
    case 'NC':
    case 'NL':
    case 'NO':
    case 'PL':
    case 'PT':
    case 'PY':
    case 'RE':
    case 'RS':
    case 'SA':
    case 'SE':
    case 'SJ':
    case 'SM':
    case 'SN':
    case 'TC':
    case 'TJ':
    case 'TM':
    case 'TN':
    case 'TZ':
    case 'UY':
    case 'VG':
    case 'ZM':
      output += i18n.ad(opt_data, opt_sb, opt_ijData);
      break;
    case 'AE':
    case 'GD':
    case 'HN':
    case 'KN':
    case 'LC':
    case 'PA':
    case 'SS':
    case 'SV':
      output += i18n.ae(opt_data, opt_sb, opt_ijData);
      break;
    case 'AF':
    case 'IR':
      output += i18n.af(opt_data, opt_sb, opt_ijData);
      break;
    case 'AG':
    case 'AO':
    case 'AW':
    case 'BJ':
    case 'BO':
    case 'BS':
    case 'BZ':
    case 'CI':
    case 'CU':
    case 'CW':
    case 'DJ':
    case 'FJ':
    case 'GA':
    case 'GH':
    case 'GM':
    case 'GY':
    case 'JM':
    case 'KE':
    case 'KI':
    case 'LY':
    case 'MW':
    case 'NA':
    case 'NR':
    case 'PS':
    case 'QA':
    case 'RW':
    case 'SC':
    case 'SR':
    case 'SX':
    case 'TG':
    case 'TT':
    case 'UG':
    case 'VU':
      output += i18n.ag(opt_data, opt_sb, opt_ijData);
      break;
    case 'AI':
    case 'AS':
    case 'BB':
    case 'BD':
    case 'BM':
    case 'BN':
    case 'BT':
    case 'DO':
    case 'FK':
    case 'FM':
    case 'GR':
    case 'GU':
    case 'JO':
    case 'KZ':
    case 'LB':
    case 'LK':
    case 'LS':
    case 'MA':
    case 'MH':
    case 'MM':
    case 'MR':
    case 'MS':
    case 'MT':
    case 'MV':
    case 'NG':
    case 'PG':
    case 'PK':
    case 'PR':
    case 'RO':
    case 'SG':
    case 'VC':
    case 'WS':
      output += i18n.ai(opt_data, opt_sb, opt_ijData);
      break;
    case 'AL':
    case 'EE':
    case 'IS':
      output += i18n.al(opt_data, opt_sb, opt_ijData);
      break;
    case 'AR':
      output += i18n.ar(opt_data, opt_sb, opt_ijData);
      break;
    case 'AT':
    case 'ES':
    case 'IL':
      output += i18n.at(opt_data, opt_sb, opt_ijData);
      break;
    case 'AU':
    case 'CA':
    case 'SZ':
    case 'US':
    case 'VI':
      output += i18n.au(opt_data, opt_sb, opt_ijData);
      break;
    case 'BE':
    case 'PE':
      output += i18n.be(opt_data, opt_sb, opt_ijData);
      break;
    case 'BF':
    case 'BI':
    case 'BQ':
    case 'BW':
    case 'CF':
    case 'CG':
    case 'CM':
    case 'DM':
    case 'ER':
    case 'GQ':
    case 'KM':
    case 'ML':
    case 'SY':
    case 'TD':
    case 'ZW':
      output += i18n.bf(opt_data, opt_sb, opt_ijData);
      break;
    case 'BG':
      output += i18n.bg(opt_data, opt_sb, opt_ijData);
      break;
    case 'BH':
      output += i18n.bh(opt_data, opt_sb, opt_ijData);
      break;
    case 'BR':
      output += i18n.br(opt_data, opt_sb, opt_ijData);
      break;
    case 'CH':
    case 'DE':
    case 'GT':
    case 'IT':
    case 'LI':
    case 'MY':
    case 'NI':
    case 'OM':
    case 'SK':
    case 'VA':
      output += i18n.ch(opt_data, opt_sb, opt_ijData);
      break;
    case 'CL':
    case 'PF':
    case 'SH':
      output += i18n.cl(opt_data, opt_sb, opt_ijData);
      break;
    case 'CN':
      output += i18n.cn(opt_data, opt_sb, opt_ijData);
      break;
    case 'CO':
    case 'CR':
    case 'ID':
    case 'IQ':
    case 'KH':
    case 'MP':
    case 'NP':
    case 'PW':
    case 'UA':
      output += i18n.co(opt_data, opt_sb, opt_ijData);
      break;
    case 'EG':
    case 'ZA':
      output += i18n.eg(opt_data, opt_sb, opt_ijData);
      break;
    case 'GB':
    case 'MN':
      output += i18n.gb(opt_data, opt_sb, opt_ijData);
      break;
    case 'GG':
    case 'IM':
    case 'JE':
      output += i18n.gg(opt_data, opt_sb, opt_ijData);
      break;
    case 'GN':
      output += i18n.gn(opt_data, opt_sb, opt_ijData);
      break;
    case 'HK':
    case 'MO':
      output += i18n.hk(opt_data, opt_sb, opt_ijData);
      break;
    case 'HR':
      output += i18n.hr(opt_data, opt_sb, opt_ijData);
      break;
    case 'HU':
    case 'SI':
      output += i18n.hu(opt_data, opt_sb, opt_ijData);
      break;
    case 'IE':
      output += i18n.ie(opt_data, opt_sb, opt_ijData);
      break;
    case 'IN':
    case 'UZ':
    case 'VE':
      output += i18n.in(opt_data, opt_sb, opt_ijData);
      break;
    case 'JP':
      output += i18n.jp(opt_data, opt_sb, opt_ijData);
      break;
    case 'KR':
      output += i18n.kr(opt_data, opt_sb, opt_ijData);
      break;
    case 'KY':
      output += i18n.ky(opt_data, opt_sb, opt_ijData);
      break;
    case 'LT':
      output += i18n.lt(opt_data, opt_sb, opt_ijData);
      break;
    case 'LV':
      output += i18n.lv(opt_data, opt_sb, opt_ijData);
      break;
    case 'MU':
      output += i18n.mu(opt_data, opt_sb, opt_ijData);
      break;
    case 'MX':
      output += i18n.mx(opt_data, opt_sb, opt_ijData);
      break;
    case 'NE':
    case 'SD':
      output += i18n.ne(opt_data, opt_sb, opt_ijData);
      break;
    case 'NZ':
      output += i18n.nz(opt_data, opt_sb, opt_ijData);
      break;
    case 'PH':
    case 'TW':
    case 'VN':
      output += i18n.ph(opt_data, opt_sb, opt_ijData);
      break;
    case 'RU':
      output += i18n.ru(opt_data, opt_sb, opt_ijData);
      break;
    case 'SB':
    case 'SL':
    case 'ST':
    case 'TL':
    case 'TO':
    case 'TV':
      output += i18n.sb(opt_data, opt_sb, opt_ijData);
      break;
    case 'TH':
    case 'TR':
      output += i18n.th(opt_data, opt_sb, opt_ijData);
      break;
    default:
      output += i18n.au(opt_data, opt_sb, opt_ijData);
      break;
  }
  return output;
};

i18n.ad = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ae = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.af = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ag = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ai = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.al = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ar = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.at = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.au = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.city) || (opt_data.profile.address.region))) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.be = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.postalCode) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.city))) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.bf = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.bg = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.bh = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.br = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ch = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.cl = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.cn = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (((((opt_data.profile.address.region) || (opt_data.profile.address.city))) || (opt_data.profile.address.sublocality))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.sublocality))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.sublocality) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.co = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.city) || (opt_data.profile.address.region))) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.eg = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((((opt_data.profile.address.sublocality) || (opt_data.profile.address.city))) || (opt_data.profile.address.region))) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (((((opt_data.profile.address.city) || (opt_data.profile.address.region))) || (opt_data.profile.address.postalCode))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.gb = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.sublocality) || (opt_data.profile.address.city))) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.gg = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.gn = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (((((opt_data.profile.address.line1) || (opt_data.profile.address.line2))) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.line2) || (opt_data.profile.address.city))) {
          output += ' ';
        }
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.hk = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.hr = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.hu = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ie = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.city) || (opt_data.profile.address.region))) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.in = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.jp = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    case 'en':
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.line1) || (opt_data.profile.address.sublocality))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.sublocality) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
    default:
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((((opt_data.profile.address.region) || (opt_data.profile.address.city))) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.line1))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (((((opt_data.profile.address.city) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.line1))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.line1))) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.line1) {
          output += ' ';
        }
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.kr = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((((opt_data.profile.address.region) || (opt_data.profile.address.city))) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.line1))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (((((opt_data.profile.address.city) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.line1))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.line1))) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.line1) {
          output += ' ';
        }
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ky = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.lt = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((((opt_data.profile.address.city) || (opt_data.profile.address.sublocality))) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.lv = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.mu = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.mx = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ne = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.region) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.nz = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ph = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.sublocality) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.region) || (opt_data.profile.address.postalCode))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.postalCode) {
          output += ' ';
        }
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.ru = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.city) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.postalCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.sb = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.city) || (opt_data.profile.address.region))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.region) {
          output += '\x3Cyxt-comma\x3E,\x3C/yxt-comma\x3E';
          output += ' ';
        }
        if (opt_data.profile.address.region) {
          output += i18n.region(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.th = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  switch (opt_data.locale) {
    default:
      if (opt_data.profile.address.line1) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line1) {
          output += i18n.address1(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.line2) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.line2) {
          output += i18n.address2(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.sublocality) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.sublocality) {
          output += i18n.sublocality(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (((opt_data.profile.address.postalCode) || (opt_data.profile.address.city))) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.postalCode) {
          output += i18n.postalCode(opt_data, opt_sb, opt_ijData);
        }
        if (opt_data.profile.address.city) {
          output += ' ';
        }
        if (opt_data.profile.address.city) {
          output += i18n.city(opt_data, opt_sb, opt_ijData);
        }
        output += ' ';
        output += '\x3C/div\x3E';
      }
      if (opt_data.profile.address.countryCode) {
        output += '\x3Cdiv class=c-AddressRow\x3E';
        if (opt_data.profile.address.countryCode) {
          output += i18n.country(opt_data, opt_sb, opt_ijData);
        }
        output += '\x3C/div\x3E';
      }
      break;
  }
  return output;
};

i18n.address1 = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  output += '\x3Cspan class=\"c-address-street-1\"\x3E';
  output += nullSafe(opt_data.profile.address.line1);
  output += '\x3C/span\x3E';
  return output;
};

i18n.address2 = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  output += '\x3Cspan class=\"c-address-street-2\"\x3E';
  output += nullSafe(opt_data.profile.address.line2);
  output += '\x3C/span\x3E';
  return output;
};

i18n.sublocality = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  output += '\x3Cspan class=\"c-address-sublocality\"\x3E';
  output += nullSafe(opt_data.profile.address.sublocality);
  output += '\x3C/span\x3E';
  return output;
};

i18n.city = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  output += '\x3Cspan class=\"c-address-city\"\x3E';
  output += nullSafe(opt_data.profile.address.city);
  output += '\x3C/span\x3E';
  return output;
};

i18n.streetSchema = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  var address11 = opt_data.profile.address.line1;
  var address22 = opt_data.profile.address.line2;
  if (!(opt_data.hideSchema)) {
    output += '\x3Cmeta itemprop=\"streetAddress\" content=\"';
    output += nullSafe(address11);
    if (address22) {
      output += ' ';
      output += nullSafe(address22);
    }
    output += '\" /\x3E';
  }
  return output;
};

i18n.localitySchema = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  var city3 = opt_data.profile.address.city;
  var sublocality4 = opt_data.profile.address.sublocality;
  if (!(opt_data.hideSchema)) {
    output += '\x3Cmeta itemprop=\"addressLocality\" content=\"';
    output += nullSafe(city3);
    if (((sublocality4) && (city3))) {
      output += ' ';
    }
    output += nullSafe(sublocality4);
    output += '\" /\x3E';
  }
  return output;
};

i18n.region = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  var region5 = ((opt_data.profile.address.region) != null ? opt_data.profile.address.region : '');
  var regionName6 = (((opt_data.derivedData == null) ? null : (opt_data.derivedData.address == null) ? null : opt_data.derivedData.address.stateName) != null ? (opt_data.derivedData == null) ? null : (opt_data.derivedData.address == null) ? null : opt_data.derivedData.address.stateName : region5);
  var abbreviated7 = ((opt_data.regionAbbr) && (((region5) != (regionName6))));
  output += '\x3C';
  if (abbreviated7) {
    output += 'abbr title=\"';
    output += nullSafe(regionName6);
    output += '\" aria-label=\"';
    output += nullSafe(regionName6);
    output += '\"';
  } else {
    output += 'span';
  }
  output += ' ';
  output += 'class=\"c-address-state\" ';
  if (!(opt_data.hideSchema)) {
    output += 'itemprop=\"addressRegion\"';
  }
  output += '\x3E';
  output += nullSafe(((opt_data.regionAbbr) ?region5:regionName6));
  output += '\x3C/';
  output += nullSafe(((abbreviated7) ?'abbr':'span'));
  output += '\x3E';
  return output;
};

i18n.postalCode = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  output += '\x3Cspan class=\"c-address-postal-code\" ';
  if (!(opt_data.hideSchema)) {
    output += 'itemprop=\"postalCode\"';
  }
  output += '\x3E';
  output += nullSafe(opt_data.profile.address.postalCode);
  output += '\x3C/span\x3E';
  return output;
};

i18n.country = function(opt_data, opt_sb, opt_ijData) {
  var output = '';
  var country8 = opt_data.profile.address.countryCode;
  var countryName9 = (((opt_data.derivedData == null) ? null : (opt_data.derivedData.address == null) ? null : opt_data.derivedData.address.countryName) != null ? (opt_data.derivedData == null) ? null : (opt_data.derivedData.address == null) ? null : opt_data.derivedData.address.countryName : country8);
  output += '\x3C';
  if (((country8) != (countryName9))) {
    output += 'abbr title=\"';
    output += nullSafe(countryName9);
    output += '\" aria-label=\"';
    output += nullSafe(countryName9);
    output += '\"';
  } else {
    output += 'span';
  }
  output += ' ';
  output += 'class=\"c-address-country-name c-address-country-';
  output += nullSafe(country8);
  output += '\"';
  if (!(opt_data.hideSchema)) {
    output += ' ';
    output += 'itemprop=\"addressCountry\"';
  }
  output += '\x3E';
  output += nullSafe(country8);
  output += '\x3C/';
  output += nullSafe(((((country8) != (countryName9))) ?'abbr':'span'));
  output += '\x3E';
  return output;
};
var nullSafe = function(x) {return x == null ? '' : x};

/**
 * ***********************************************************************
 * ------------------------ GENERATED CODE ENDS ------------------------
 * ***********************************************************************
 */


</script>